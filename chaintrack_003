--scaling
sc = 1/2

--laying parallel to the ground
function mycyl(radius,length)
  return translate(-length/2,0,radius)*
    rotate(0,90,0)*
    cylinder(radius,length)
end

--laying on the ground
function mybox(x,y,z)
  return translate(0,0,z/2)*
    box(x,y,z)
end

--base plate
width = 80
length = 25 -- total 12 shall fit on the power wheel
height = 1
radius = (25*12)/(2*math.pi) -- = 47,75 -power wheel

roundingcylz = math.sqrt(radius*radius-(length/2)*(length/2)) --point of rotation
roundingangle = math.deg(math.asin((length/2)/radius)) + 10
gapx = 1/sc

--chain
cradius = 6 --point of rotation
caxis = 2  --axis radius
ctube = 4  --radius of the tube
cspace = 9 --space between supports
cwidth = 2 --support width
cgap = 0.5  --extra gap between inner and outer wall
cw1 = cwidth + cspace + cwidth
cs2 = cgap + cwidth + cspace + cwidth + cgap
cw2 = cgap + cwidth + cwidth + cspace + cwidth + cwidth + cgap
gapy = 0.5/sc
shift = 3

baseplate_raw = mybox(width,length,height)                    --baseplate
baseplate_curving = difference{
  translate(0,0,roundingcylz-radius+0)*mycyl(radius,width),   --cylinder for front step up
  translate(0,0,roundingcylz-radius+1)*mycyl(radius-1,width), --make it empty
  translate(0,0,-2*radius)*mybox(width,2*radius,2*radius),    --flatten the base
  translate(0,0, 2*height)*mybox(width,2*radius,2*radius),    --flatton the top, leaving 2xheight
  translate(0,-radius, height)*mybox(width,2*radius,1),       --flatten the back of the top
  translate(0,radius,radius)*rotate(roundingangle,0,0)*
    translate(0,0,-radius)*mybox(width,2*radius,2*radius)     --remove sharp tip from the front step
}
baseplate_cutouts = difference(                               --allow space to make it fit
  translate(0,length/2+cradius,0)*mybox(cw2+gapx, 2*cradius, 2*cradius),
  translate(0,length/2+cradius,0)*mybox(cw1, 2*cradius, 2*cradius)
)

baseplate_raw = union(
  baseplate_raw,
  baseplate_curving
)

baseplate_raw_stabilized = difference(                        --stabilize the chain_back with two blocks
  translate(0,length/2+cradius,0)*mybox(cw2, 2*cradius, 2*cradius),
  translate(0,length/2+cradius,0)*mybox(cs2, 2*cradius, 2*cradius)
)
baseplate_raw_stabilized = difference(
  baseplate_raw,
  baseplate_raw_stabilized
)

baseplate = difference{
  baseplate_raw,
  translate(0,-length+gapx,0)*baseplate_raw_stabilized,
  baseplate_cutouts
}
chain_front = difference{
  union (
    translate(0,length/2-cradius,0)*mybox(cw1, 2*cradius, 2*cradius),  --walls
    translate(0,length/2,0)*mycyl(cradius,cw1)                         --round
  ),
  translate(0,length/2,cradius-caxis)*mycyl(caxis,width),              --axis
  translate(0,length/2-cradius,0)*mybox(cspace, 2*cradius, 2*cradius), --walls
  translate(0,length/2,0)*mycyl(cradius,cspace)                        --round
}
chain_front = union {
  chain_front,
  difference(
    translate(0,length/2,cradius-2*caxis)*mycyl(2*caxis,cw1),           --mitnehmer
    translate(0,length/2,cradius-caxis)*mycyl(caxis,width)              --axis
  ),
  translate(0,length/2,1)*mybox(cw1,1,2)
}
--emit(scale(sc)*translate(0,shift,height)*translate(0,length/2,1)*mybox(cw1,1,1),2)

chain_back = difference{
  union (
    translate(0,-length/2+cradius,0)*mybox(cw2, 2*cradius, 2*cradius), --walls
    translate(0,-length/2,0)*mycyl(cradius,cw2)                        --round
  ),
  translate(0,-length/2,cradius-caxis)*mycyl(caxis,width),              --axis
  --translate(0,-length/2+cradius,0)*mybox(cs2, 2*cradius, 2*cradius),  --walls
  translate(0,-length/2,0)*mybox(cs2+gapy, 2.5*cradius, 2*cradius),     --walls, cut extra gap for printing
  translate(0,-length/2,0)*mycyl(cradius,cs2),                          --round
}

chain_connector = difference(                                           --interconnect chain_front and chain_back
  mybox(cw2,2*cradius,2*cradius),
  mybox(cspace,2*cradius,2*cradius)
)

chain = translate(0,shift,height)*union{
  chain_front,
  chain_back,
  chain_connector
}

chaintrack = union(
  baseplate,
  chain
)
emit(scale(sc)*chaintrack)
--emit(scale(sc)*translate(0,length,0)*chaintrack)
--emit(scale(sc)*translate(0,-length,0)*chaintrack)

